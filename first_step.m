function [Ac,C,n,x_1,x_l0,U1_up,A,failed] = first_part(H1,h1_up,id_meth_params)
    %originates from ERA algorithm for identification of linear systems  
    failed=0;   
    Ac=[];C=[];x_1=[];U1=[];
    %svd decomposition of first Hankel matrix
    [U,S,V] = svd(H1); 
    
    S
    
    %order of the system
    n=rank(H1,1*10^-6);
    
    % alpha must be chosen that (alpha-1)*m>n
    %if((id_meth_params.alpha-1)*id_meth_params.m<=n)
    %    failed=1;
    %    disp('increase alpha!')
    %    return
    %end
    
    % p must be chosen that p-1>=n 
    %if(id_meth_params.p-1<n)
    %    failed=1;
    %    disp('Error!')
    %    disp('System identification method requires at least (n+1) sets of responses')
    %    disp('generated by (n+1) different time periods of pulse input!')
    %    disp('increase p!')
    %    return
    %end
    
    U1=U(1:(id_meth_params.alpha*id_meth_params.m),1:n);
    rank(U1);
    S1=S(1:n,1:n);
    V1=V(1:(id_meth_params.beta),1:n);
    
    %identification of matrix C
    C=U1(1:id_meth_params.m,:)
    
    %matrix B1_dashed -  used in second part
    S1V1T=S1*V1';
    x_1=S1V1T(:,1)
    
   %identification of matrix Ac
   U1_up=U1(1:(id_meth_params.alpha-1)*id_meth_params.m,:);
   rank(U1_up);
   U1_down=U1((id_meth_params.m+1):id_meth_params.alpha*id_meth_params.m,:);
   rank(U1_down);
   A=U1_up\U1_down;
   Ac=logm(A)/id_meth_params.delta_t;
   
   (U1_up\h1_up);
   
   %choose just one way
   x_l0=A^(id_meth_params.l0)*x_1;
   x_l0=A^(id_meth_params.l0)*(U1_up\h1_up)
   
    
   %check if eigenvalues of sys_spec.Ac and Ac are the same
   %Ac_eig=eig(Ac);
   %original_Ac=eig(sys_spec.Ac);   
end
 